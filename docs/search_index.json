[["creating-corpus.html", "Chapter 3 Creating Corpus 3.1 HTML Structure 3.2 Web Crawling 3.3 Functional Programming 3.4 Save Corpus 3.5 Additional Resources 3.6 Final Remarks", " Chapter 3 Creating Corpus Linguistic data are important to us linguists. Data usually tell us something we don’t know, or something we are not sure of. In this chapter, I would like to show you a quick way to extract linguistic data from web pages, which is by now undoubtedly the largest source of textual data available. While there are many existing text data collections (cf. Structured Corpus and XML), chances are that sometimes you still need to collect your own data for a particular research question. But please note that when you are creating your own corpus for specific research questions, always pay attention to the three important criteria: representativeness, authenticity, and size. Following the spirit of tidy , we will mainly do our tasks with the libraries of tidyverse and rvests. If you are new to tidyverse R, please check its official webpage for learning resources. ## Uncomment the following line for installation # install.packages(c(&quot;tidyverse&quot;, &quot;rvest&quot;)) library(tidyverse) library(rvest) 3.1 HTML Structure The HyperText Markup Language, or HTML is the standard markup language for documents designed to be displayed in a web browser. 3.1.1 HTML Syntax To illustrate the structure of the HTML, please download the sample html file from: demo_data/data-sample-html.html and first open it with your browser. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;My First HTML &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; Introduction &lt;/h1&gt; &lt;p&gt; Have you ever read the source code of a html page? This is how to get back to the course page: &lt;a href=&quot;https://alvinntnu.github.io/NTNU_ENC2036_LECTURES/&quot;, target=&quot;_blank&quot;&gt;ENC2036&lt;/a&gt;. &lt;/p&gt; &lt;h1&gt; Contents of the Page &lt;/h1&gt; &lt;p&gt; Anything you can say about the page.....&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; An HTML document includes several important elements (cf. Figure 3.1): DTD: document type definition which informs the browser about the version of the HTML standard that the document adheres to (e.g., &lt;!DOCTYPE HTML&gt;) element: the combination of start tag, content, and end tag (e.g, &lt;title&gt;My First HTML&lt;/title&gt;) tag: named braces that enclose the content and define its structural function (e.g., title, body, p) attribute: specific properties of the tag, which are often placed in the start end of the element (e.g., &lt;a href= \"index.html\"&gt; Homepage &lt;/a&gt;). They are expressed as name = \"value\" pairs. Figure 3.1: Syntax of An HTML Tag Element An HTML document starts with the root element &lt;html&gt;, which splits into two branches, &lt;head&gt; and &lt;body&gt;. Most of the webpage textual contents would go into the &lt;body&gt; part. Most of the web-related codes and metadata (e.g., javascripts, CSS) are often included in the &lt;head&gt; part. All elements need to be strictly nested within each other in a well-formed and valid HTML file, as shown in Figure 3.2. Figure 3.2: Tree Structure of An HTML Document 3.1.2 Tags and Attributes HTML has plenty of legal tags and attributes. On W3CSchools, there is a complete list of HTML tags and attributes for your reference. Common tags may include: Anchor tag &lt;a&gt; Metadata tag &lt;meta&gt; External tag &lt;link&gt; Emphasizing tags &lt;b&gt;, &lt;i&gt;, &lt;strong&gt; Paragraph tags &lt;p&gt; Heading tags &lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt; Listing content tags &lt;ul&gt;, &lt;ol&gt; Block tags &lt;div&gt;, &lt;span&gt; Form-related tag &lt;form&gt;, &lt;input&gt; Foreign script tag &lt;script&gt; Table tag &lt;table&gt;, &lt;th&gt;, &lt;tr&gt;, &lt;td&gt; You probably don’t have to know all the detail about the HTML tags and elements. However, in order to scrape the textual data from the Internet, you need to know at least from which parts of HTML elements you need your textual data from on the web pages. Usually, before you scrape the data from the webpage, bear the following questions in mind: From which HTML elements/tags would you like to extract the data for corpus construction? Do you need the textual content of the HTML element? Do you need a specific attribute of the HTML element? 3.1.3 CSS Cascading Style Sheet (CSS) is a language for describing the layout of HTML and other markup documents (e.g., XML). HTML + CSS is by now the standard way to create and design web pages. The idea is that CSS specifies the formats/styles of the HTML elements. The following is an example of the CSS: div.warnings { color: pink; font-family: &quot;Arial&quot; font-size: 120% } h1 { padding-top: 20px padding-bottom: 20px } div.warnings { color: pink; font-family: \"Arial\" font-size: 120% } h1 { padding-top: 20px padding-bottom: 20px } You probably would wonder how to link a set of CSS style definitions to an HTML document. There are in general three ways: inline, internal and external. You can learn more about this in W3School.com. Here I will show you an example of the internal method. Below is a CSS style definition for &lt;h1&gt;. h1 { color: red; margin-bottom: 2em; } We can embed this within a &lt;style&gt;...&lt;/style&gt; element. Then you put the entire &lt;style&gt; element under &lt;head&gt; of the HTML file you would like to style. &lt;style&gt; h1 { color: red; margin-bottom: 1.5em; } &lt;/style&gt; After you include the &lt;style&gt; in the HTML file, refresh the web page to see if the CSS style works. 3.1.4 HTML + CSS ( + JavaScript) Try it: HTML: the language for building web pages CSS: the language for styling web pages JavaScript: the language for programming web pages 3.2 Web Crawling In the following demonstration, the text data scraped from the PTT forum is presented as it is without adjustment. However, please note that the language on PTT may strike some readers as profane, vulgar or even offensive. library(tidyverse) library(rvest) In this tutorial, let’s assume that we like to scrape texts from PTT Forum. In particular, we will demonstrate how to scrape texts from the Gossiping board of PTT. ptt.url &lt;- &quot;https://www.ptt.cc/bbs/Gossiping&quot; If you use your browser to view PTT Gossiping page, you would see that you need to go through the age verification before you can enter the content page. So, our first job is to pass through this age verification. First, we create an session() (like we open a browser linking to the page) gossiping.session &lt;- session(ptt.url) Second, we extract the age verification form from the current page (form is also a defined HTML element) gossiping.form &lt;- gossiping.session %&gt;% html_node(&quot;form&quot;) %&gt;% html_form Then we automatically submit an yes to the age verification form in the earlier created session() and create another session. gossiping &lt;- session_submit( x = gossiping.session, form = gossiping.form, submit = &quot;yes&quot; ) gossiping &lt;session&gt; https://www.ptt.cc/bbs/Gossiping/index.html Status: 200 Type: text/html; charset=utf-8 Size: 8578 Now our html session, i.e., gossiping, should be on the front page of the Gossiping board. Most browsers come with the functionality to inspect the page source (i.e., HTML). This is very useful for web crawling. Before we scrape data from the webpage, we often need to inspect the structure of the web page first. Most importantly, we need to know (a) which HTML elements, or (b) which particular attributes/values of the HTML elements we are interested in . Next we need to find the most recent index page of the board # Decide the number of index pages ---- page.latest &lt;- gossiping %&gt;% html_nodes(&quot;a&quot;) %&gt;% # extract all &lt;a&gt; elements html_attr(&quot;href&quot;) %&gt;% # extract the attributes `href` str_subset(&quot;index[0-9]{2,}\\\\.html&quot;) %&gt;% # find the `href` with the index number str_extract(&quot;[0-9]+&quot;) %&gt;% # extract the number as.numeric() page.latest [1] 39484 On the most recent index page, we need to extract the hyperlinks to the articles # Retreive links ----- link &lt;- str_c(ptt.url, &quot;/index&quot;, page.latest, &quot;.html&quot;) links.article &lt;- gossiping %&gt;% session_jump_to(link) %&gt;% # move session to the most recent page html_nodes(&quot;a&quot;) %&gt;% # extract article &lt;a&gt; html_attr(&quot;href&quot;) %&gt;% # extract article &lt;a&gt; `href` attributes str_subset(&quot;[A-z]\\\\.[0-9]+\\\\.[A-z]\\\\.[A-z0-9]+\\\\.html&quot;) %&gt;% # extract links str_c(&quot;https://www.ptt.cc&quot;,.) links.article [1] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351291.A.5A1.html&quot; [2] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351387.A.5F9.html&quot; [3] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351400.A.06D.html&quot; [4] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351508.A.3DA.html&quot; [5] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351590.A.719.html&quot; [6] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351706.A.7B1.html&quot; [7] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351742.A.459.html&quot; [8] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351759.A.D79.html&quot; [9] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351773.A.329.html&quot; [10] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351864.A.759.html&quot; [11] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351918.A.594.html&quot; [12] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351928.A.42C.html&quot; [13] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351960.A.831.html&quot; [14] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352057.A.FE4.html&quot; [15] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352067.A.914.html&quot; [16] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352080.A.F11.html&quot; [17] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352097.A.7D9.html&quot; [18] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352127.A.BE8.html&quot; [19] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352138.A.46B.html&quot; [20] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352194.A.38C.html&quot; Next step is to scrape texts from each article hyperlink. Let’s consider one link first. article.url &lt;- links.article[1] temp.html &lt;- gossiping %&gt;% session_jump_to(article.url) # link to the article Now the temp.html is like a browser on the article page. Because we are interested in the metadata and the contents of each article, now the question is: where are they in the HTML? We need to go back to the source page of the article HTML again: After a closer inspection of the article HTML, we know that: The metadata of the article are included in &lt;span&gt; tag elements, belonging to the class class=\"article-meta-value\" The contents of the article are included in the &lt;div&gt; element, whose ID is ID=\"main-content\" Now we are ready to extract the metadata of the article. # Extract article metadata article.header &lt;- temp.html %&gt;% html_nodes(&quot;span.article-meta-value&quot;) %&gt;% # get &lt;span&gt; of a particular class html_text() article.header [1] &quot;yata4547 (yata)&quot; &quot;Gossiping&quot; [3] &quot;[問卦] 才3月為什麼就停電&quot; &quot;Fri Mar 4 07:48:09 2022&quot; The metadata of each PTT article in fact includes four pieces of information: author, board name, title, post time. The above code retrieves directly the values of these metadata. We can retrieve the tags of these metadata values as well: temp.html %&gt;% html_nodes(&quot;span.article-meta-tag&quot;) %&gt;% # get &lt;span&gt; of a particular class html_text() [1] &quot;作者&quot; &quot;看板&quot; &quot;標題&quot; &quot;時間&quot; From the article.header, we are able to extract the author, title, and time stamp of the article. article.author &lt;- article.header[1] %&gt;% str_extract(&quot;^[A-z0-9_]+&quot;) # athuor article.title &lt;- article.header[3] # title article.datetime &lt;- article.header[4] # time stamp article.author [1] &quot;yata4547&quot; article.title [1] &quot;[問卦] 才3月為什麼就停電&quot; article.datetime [1] &quot;Fri Mar 4 07:48:09 2022&quot; Now we extract the main contents of the article article.content &lt;- temp.html %&gt;% html_nodes( # article body xpath = &#39;//div[@id=&quot;main-content&quot;]/node()[not(self::div|self::span[@class=&quot;f2&quot;])]&#39; ) %&gt;% html_text(trim = TRUE) %&gt;% # extract texts str_c(collapse = &quot;&quot;) # combine all lines into one article.content [1] &quot;現在才3月 很少人開冷氣\\n\\n用電量應該不大才對\\n\\n那等到夏天\\n\\n家家戶戶都開著冷氣\\n\\n那不就完了\\n\\n反正喊個抗中保台 騙騙賤民 亂搞也沒差\\n\\n--&quot; XPath (or XML Path Language) is a query language which is useful for addressing and extracting particular elements from XML/HTML documents. XPath allows you to exploit more features of the hierarchical tree that an HTML file represents in locating the relevant HTML elements. For more information, please see Munzert et al. (2014), Chapter 4. In the above example, the XPath identifies the nodes under &lt;div id = “main-content”&gt;, but excludes sister nodes that are &lt;div&gt; or &lt;span class=“f2”&gt;. These children &lt;div&gt; or &lt;span class=“f2”&gt; of the &lt;div id = “main-content”&gt; include the push comments (推文) of the article, which are not the main content of the article. Now we can combine all information related to the article into a data frame article.table &lt;- tibble( datetime = article.datetime, title = article.title, author = article.author, content = article.content, url = article.url ) article.table Next we extract the push comments at the end of the article article.push &lt;- temp.html %&gt;% html_nodes(xpath = &quot;//div[@class = &#39;push&#39;]&quot;) article.push {xml_nodeset (18)} [1] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;f1 hl push-tag&quot;&gt;噓 &lt;/span&gt;&lt;span class=&quot;f ... [2] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;hl push-tag&quot;&gt;推 &lt;/span&gt;&lt;span class=&quot;f3 h ... [3] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;hl push-tag&quot;&gt;推 &lt;/span&gt;&lt;span class=&quot;f3 h ... [4] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;hl push-tag&quot;&gt;推 &lt;/span&gt;&lt;span class=&quot;f3 h ... [5] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;hl push-tag&quot;&gt;推 &lt;/span&gt;&lt;span class=&quot;f3 h ... [6] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;hl push-tag&quot;&gt;推 &lt;/span&gt;&lt;span class=&quot;f3 h ... [7] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;hl push-tag&quot;&gt;推 &lt;/span&gt;&lt;span class=&quot;f3 h ... [8] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;f1 hl push-tag&quot;&gt;→ &lt;/span&gt;&lt;span class=&quot;f ... [9] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;f1 hl push-tag&quot;&gt;→ &lt;/span&gt;&lt;span class=&quot;f ... [10] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;f1 hl push-tag&quot;&gt;→ &lt;/span&gt;&lt;span class=&quot;f ... [11] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;hl push-tag&quot;&gt;推 &lt;/span&gt;&lt;span class=&quot;f3 h ... [12] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;f1 hl push-tag&quot;&gt;→ &lt;/span&gt;&lt;span class=&quot;f ... [13] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;hl push-tag&quot;&gt;推 &lt;/span&gt;&lt;span class=&quot;f3 h ... [14] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;hl push-tag&quot;&gt;推 &lt;/span&gt;&lt;span class=&quot;f3 h ... [15] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;hl push-tag&quot;&gt;推 &lt;/span&gt;&lt;span class=&quot;f3 h ... [16] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;hl push-tag&quot;&gt;推 &lt;/span&gt;&lt;span class=&quot;f3 h ... [17] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;f1 hl push-tag&quot;&gt;→ &lt;/span&gt;&lt;span class=&quot;f ... [18] &lt;div class=&quot;push&quot;&gt;\\n&lt;span class=&quot;f1 hl push-tag&quot;&gt;→ &lt;/span&gt;&lt;span class=&quot;f ... We then extract relevant information from each push nodes article.push. push types push authors push contents # push tags push.table.tag &lt;- article.push %&gt;% html_nodes(&quot;span.push-tag&quot;) %&gt;% html_text(trim = TRUE) # push types (like or dislike) push.table.tag [1] &quot;噓&quot; &quot;推&quot; &quot;推&quot; &quot;推&quot; &quot;推&quot; &quot;推&quot; &quot;推&quot; &quot;→&quot; &quot;→&quot; &quot;→&quot; &quot;推&quot; &quot;→&quot; &quot;推&quot; &quot;推&quot; &quot;推&quot; [16] &quot;推&quot; &quot;→&quot; &quot;→&quot; # push authors push.table.author &lt;- article.push %&gt;% html_nodes(&quot;span.push-userid&quot;) %&gt;% html_text(trim = TRUE) # author push.table.author [1] &quot;Roooz&quot; &quot;hatephubbing&quot; &quot;ots625&quot; &quot;greensaru&quot; &quot;pureworld&quot; [6] &quot;ymib&quot; &quot;gginin7878&quot; &quot;rererere147&quot; &quot;s999132&quot; &quot;kcclasaki&quot; [11] &quot;g1254501&quot; &quot;g1254501&quot; &quot;tonyian&quot; &quot;swanc&quot; &quot;cat5672&quot; [16] &quot;daphney2266&quot; &quot;snow3804&quot; &quot;Lowpapa&quot; # push contents push.table.content &lt;- article.push %&gt;% html_nodes(&quot;span.push-content&quot;) %&gt;% html_text(trim = TRUE) push.table.content [1] &quot;: 反核就是ㄏ&quot; [2] &quot;: 太陽罷工&quot; [3] &quot;: 事先演練&quot; [4] &quot;: ATM壞掉惹，錢領不出來，嘻嘻&quot; [5] &quot;: 缺電&quot; [6] &quot;: 電都被藏起來了&quot; [7] &quot;: https://youtu.be/gbEhkA46mDk&quot; [8] &quot;: 不是停電 是人為疏失&quot; [9] &quot;: 窩不知道&quot; [10] &quot;: 坐等班班有冷氣的到來&quot; [11] &quot;: 4%仔不造謠會死膩？是沒有太陽 不是缺電&quot; [12] &quot;: ！&quot; [13] &quot;: https://i.imgur.com/yV3D8p1.jpg&quot; [14] &quot;: 窩不知道&quot; [15] &quot;: https://imgur.com/VGRCVJF.jpg&quot; [16] &quot;: 還有班班有冷氣的到來...&quot; [17] &quot;: 先讓你習慣&quot; [18] &quot;: 太陽&quot; # push time push.table.datetime &lt;- article.push %&gt;% html_nodes(&quot;span.push-ipdatetime&quot;) %&gt;% html_text(trim = TRUE) # push time stamp push.table.datetime [1] &quot;114.137.73.98 03/04 07:49&quot; &quot;111.71.20.72 03/04 07:49&quot; [3] &quot;114.47.58.54 03/04 07:49&quot; &quot;223.137.213.87 03/04 07:49&quot; [5] &quot;136.52.32.183 03/04 07:49&quot; &quot;1.200.41.224 03/04 07:49&quot; [7] &quot;111.251.62.141 03/04 07:50&quot; &quot;101.9.239.82 03/04 07:51&quot; [9] &quot;36.237.44.200 03/04 07:51&quot; &quot;180.217.213.98 03/04 07:51&quot; [11] &quot;111.83.1.103 03/04 07:52&quot; &quot;111.83.1.103 03/04 07:52&quot; [13] &quot;39.9.229.252 03/04 07:52&quot; &quot;49.217.177.133 03/04 07:54&quot; [15] &quot;49.216.47.100 03/04 07:55&quot; &quot;140.127.221.10 03/04 07:55&quot; [17] &quot;1.164.187.94 03/04 07:56&quot; &quot;61.228.93.108 03/04 07:57&quot; Finally, we combine all into one Push data frame. push.table &lt;- tibble( tag = push.table.tag, author = push.table.author, content = push.table.content, datetime = push.table.datetime, url = article.url) push.table 3.3 Functional Programming It should now be clear that there are several routines that we need to do again and again if we want to collect text data in large amounts: For each index page, we need to extract all the article hyperlinks of the page. For each article hyperlink, we need to extract the article content, metadata, and the push comments. So, it would be great if we can wrap these two routines into two functions. 3.3.1 extract_art_links() extract_art_links(): This function takes an HTML session session and an index page of the PTT Gossiping index_page as the arguments and extract all article links from the index page. It returns a vector of article links. extract_art_links &lt;- function(index_page, session){ links.article &lt;- session %&gt;% session_jump_to(index_page) %&gt;% html_nodes(&quot;a&quot;) %&gt;% html_attr(&quot;href&quot;) %&gt;% str_subset(&quot;[A-z]\\\\.[0-9]+\\\\.[A-z]\\\\.[A-z0-9]+\\\\.html&quot;) %&gt;% str_c(&quot;https://www.ptt.cc&quot;,.) return(links.article) } For example, we can extract all the article links from the most recent index page: # Get index page cur_index_page &lt;- str_c(ptt.url, &quot;/index&quot;, page.latest, &quot;.html&quot;) # Get all article links from the most recent index page cur_art_links &lt;-extract_art_links(cur_index_page, gossiping) cur_art_links [1] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351291.A.5A1.html&quot; [2] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351387.A.5F9.html&quot; [3] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351400.A.06D.html&quot; [4] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351508.A.3DA.html&quot; [5] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351590.A.719.html&quot; [6] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351706.A.7B1.html&quot; [7] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351742.A.459.html&quot; [8] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351759.A.D79.html&quot; [9] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351773.A.329.html&quot; [10] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351864.A.759.html&quot; [11] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351918.A.594.html&quot; [12] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351928.A.42C.html&quot; [13] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646351960.A.831.html&quot; [14] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352057.A.FE4.html&quot; [15] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352067.A.914.html&quot; [16] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352080.A.F11.html&quot; [17] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352097.A.7D9.html&quot; [18] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352127.A.BE8.html&quot; [19] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352138.A.46B.html&quot; [20] &quot;https://www.ptt.cc/bbs/Gossiping/M.1646352194.A.38C.html&quot; 3.3.2 extract_article_push_tables() extract_article_push_tables(): This function takes an article link link as the argument and extracts the metadata, textual contents, and pushes of the article. It returns a list of two elements—article and push data frames. extract_article_push_tables &lt;- function(link){ article.url &lt;- link temp.html &lt;- gossiping %&gt;% session_jump_to(article.url) # link to the www # article header article.header &lt;- temp.html %&gt;% html_nodes(&quot;span.article-meta-value&quot;) %&gt;% # meta info regarding the article html_text() # article meta article.author &lt;- article.header[1] %&gt;% str_extract(&quot;^[A-z0-9_]+&quot;) # athuor article.title &lt;- article.header[3] # title article.datetime &lt;- article.header[4] # time stamp # article content article.content &lt;- temp.html %&gt;% html_nodes( # article body xpath = &#39;//div[@id=&quot;main-content&quot;]/node()[not(self::div|self::span[@class=&quot;f2&quot;])]&#39; ) %&gt;% html_text(trim = TRUE) %&gt;% str_c(collapse = &quot;&quot;) # Merge article table article.table &lt;- tibble( datetime = article.datetime, title = article.title, author = article.author, content = article.content, url = article.url ) # push nodes article.push &lt;- temp.html %&gt;% html_nodes(xpath = &quot;//div[@class = &#39;push&#39;]&quot;) # extracting pushes # NOTE: If CSS is used, div.push does a lazy match (extracting div.push.... also) # push tags push.table.tag &lt;- article.push %&gt;% html_nodes(&quot;span.push-tag&quot;) %&gt;% html_text(trim = TRUE) # push types (like or dislike) # push author id push.table.author &lt;- article.push %&gt;% html_nodes(&quot;span.push-userid&quot;) %&gt;% html_text(trim = TRUE) # author # push content push.table.content &lt;- article.push %&gt;% html_nodes(&quot;span.push-content&quot;) %&gt;% html_text(trim = TRUE) # push datetime push.table.datetime &lt;- article.push %&gt;% html_nodes(&quot;span.push-ipdatetime&quot;) %&gt;% html_text(trim = TRUE) # push time stamp # merge push table push.table &lt;- tibble( tag = push.table.tag, author = push.table.author, content = push.table.content, datetime = push.table.datetime, url = article.url ) # return return(list(article.table = article.table, push.table = push.table)) }#endfunc For example, we can get the article and push tables from the first article link: extract_article_push_tables(cur_art_links[1]) $article.table # A tibble: 1 × 5 datetime title author content url &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Fri Mar 4 07:48:09 2022 [問卦] 才3月為什麼就停電 yata4547 &quot;現在才3月… https:… $push.table # A tibble: 18 × 5 tag author content datetime url &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 噓 Roooz : 反核就是ㄏ 114.137.7… https:… 2 推 hatephubbing : 太陽罷工 111.71.20… https:… 3 推 ots625 : 事先演練 114.47.58… https:… 4 推 greensaru : ATM壞掉惹，錢領不出來，嘻嘻 223.137.2… https:… 5 推 pureworld : 缺電 136.52.32… https:… 6 推 ymib : 電都被藏起來了 1.200.41.… https:… 7 推 gginin7878 : https://youtu.be/gbEhkA46mDk 111.251.6… https:… 8 → rererere147 : 不是停電 是人為疏失 101.9.239… https:… 9 → s999132 : 窩不知道 36.237.44… https:… 10 → kcclasaki : 坐等班班有冷氣的到來 180.217.2… https:… 11 推 g1254501 : 4%仔不造謠會死膩？是沒有太陽 不是缺電 111.83.1.… https:… 12 → g1254501 : ！ 111.83.1.… https:… 13 推 tonyian : https://i.imgur.com/yV3D8p1.jpg 39.9.229.… https:… 14 推 swanc : 窩不知道 49.217.17… https:… 15 推 cat5672 : https://imgur.com/VGRCVJF.jpg 49.216.47… https:… 16 推 daphney2266 : 還有班班有冷氣的到來... 140.127.2… https:… 17 → snow3804 : 先讓你習慣 1.164.187… https:… 18 → Lowpapa : 太陽 61.228.93… https:… 3.3.3 Streamline the Codes Now we can simplify our codes quite a bit: # Get index page cur_index_page &lt;- str_c(ptt.url, &quot;/index&quot;, page.latest, &quot;.html&quot;) # Scrape all article.tables and push.tables from each article hyperlink cur_index_page %&gt;% extract_art_links(session = gossiping) %&gt;% map(extract_article_push_tables) -&gt; ptt_data # number of articles on this index page length(ptt_data) [1] 20 # Check the first contents of 1st hyperlink ptt_data[[1]]$article.table ptt_data[[1]]$push.table Finally, the last thing we can do is to combine all article tables from each index page into one; and all push tables into one for later analysis. # Merge all article.tables into one article.table.all &lt;- ptt_data %&gt;% map(function(x) x$article.table) %&gt;% bind_rows # Merge all push.tables into one push.table.all &lt;- ptt_data %&gt;% map(function(x) x$push.table) %&gt;% bind_rows article.table.all push.table.all There is still one problem with the Push data frame. Right now it is still not very clear how we can match the pushes to the articles from which they were extracted. The only shared index is the url. It would be better if all the articles in the data frame have their own unique indices and in the Push data frame each push comment corresponds to a particular article index. The following graph summarizes our work flowchart for PTT Gossipping Scraping: 3.4 Save Corpus You can easily save your scraped texts in a CSV format. # Save ------ write_csv(article.table, path = &quot;PTT_GOSSIPPING_ARTICLE.csv&quot;) write_csv(push.table, path = &quot;PTT_GOSSIPPING_PUSH.csv&quot;) 3.5 Additional Resources Collecting texts and digitizing them into machine-readable files is only the initial step for corpus construction. There are many other things that need to be considered to ensure the effectiveness and the sustainability of the corpus data. In particular, I would like to point you to a very useful resource, Developing Linguistic Corpora: A Guide to Good Practice, compiled by Martin Wynne. Other important issues in corpus creation include: Adding linguistic annotations to the corpus data (cf. Leech’s Chapter 2) Metadata representation of the documents (cf. Burnard’s Chapter 4) Spoken corpora (cf. Thompson’s Chapter 5) Technical parts for corpus creation (cf. Sinclair’s Appendix) 3.6 Final Remarks Please pay attention to the ethical aspects involved in the process of web crawling (esp. with personal private matters). If the website has their own API built specifically for one to gather data, use it instead of scraping. Always read the terms and conditions provided by the website regarding data gathering. Always be gentle with the data scraping (e.g., off-peak hours, spacing out the requests) Value the data you gather and treat the data with respect. Exercise 3.1 Can you modify the R codes so that the script can automatically scrape more than one index page? Exercise 3.2 Please utilize the code from Exercise 3.1 and collect all texts on PTT/Gossipings from 3 index pages. Please have the articles saved in PTT_GOSSIPING_ARTICLE.csv and the pushes saved in PTT_GOSSIPING_PUSH.csv under your working directory. Also, at the end of your code, please also output in the Console the corpus size, including both the articles and the pushes. Please provide the total number of characters of all your PTT text data collected (Note: You DO NOT have to do the word segmentation yet. Please use the characters as the base unit for corpus size.) Hint: nchar() Your script may look something like: # I define my own `scrapePTT()` function: # ptt_url: specify the board to scrape texts from # num_index_page: specify the number of index pages to be scraped # return: list(article, push) PTT_data &lt;-scrapePTT(ptt_url = &quot;https://www.ptt.cc/bbs/Gossiping&quot;, num_index_page = 3) PTT_data$article %&gt;% head PTT_data$push %&gt;% head # corpus size PTT_data$article$content %&gt;% nchar %&gt;% sum [1] 24039 Exercise 3.3 Please choose a website (other than PTT) you are interested in and demonstrate how you can use R to retrieve textual data from the site. The final scraped text collection could be from only one static web page. The purpose of this exercise is to show that you know how to parse the HTML structure of the web page and retrieve the data you need from the website. References Munzert, S., Rubba, C., Meißner, P., &amp; Nyhuis, D. (2014). Automated data collection with R: A practical guide to web scraping and text mining. John Wiley &amp; Sons. "]]
